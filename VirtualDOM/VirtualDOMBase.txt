VirtualDOM 的来源： 

在 react 中，主要原理之一： 

    页面生成方案一：
        页面第一次渲染：
                1 state 数据； 
                2 JSX 模板；
                3 数据 + 模板 结合，生成真实的 DOM，来显示在页面上；
        页面发生数据发生改变： 
                4 当 state 数据发生改变；
                5 模板 + 数据 结合，生成真实的 DOM，替换原来的 DOM； 

    以上方案缺陷： 
        第一次生成一个完整的 DOM 片段；
        第二次生成一个完整的 DOM 片段；
        第二次生成的 DOM替换第一次生成的 DOM；非常的耗费性能；

    页面生成方案二： 
        页面第一次渲染：
                1 state 数据； 
                2 JSX 模板；
                3 数据 + 模板 结合，生成真实的 DOM，来显示在页面上；
        页面发生数据发生改变： 
                4 当 state 数据发生改变；
                5 旧模板 + 数据 结合，生成真实的 DOM，并不替换原来的 DOM； 
                6 新的 DOM（docementFragment）和原来的 DOM 作对比，寻找差异；
                7 找出DOM 变化的地方；
                8 只有新的 DOM 中的 元素 替换老的 DOM 中发生变化的 DOM 元素；

    以上方案缺陷：
        性能得到一定的提高； 但是在对比差异的时候也会耗费一定的性能；性能的提升不是很好；也不是最优；

    页面生成方案三： 
        页面第一次渲染：
                1 state 数据； 
                2 JSX 模板；
                3 数据 + 模板 结合，生成真实的 DOM，来显示在页面上；
                4 生成虚拟 DOM； （虚拟 DOM 就是一个js 对象，用它来描述真实 DOM）；
                    语法： <div id="abc"> <span> hello world </span></div>;
                        [ 标签名（‘div’）,标签属性-- {id: 'abc'} , 内容-- [ 标签名-- 'span', 标签属性--- {}，标签内容--- ‘hello world’]],
                5 state 发生变化；
                6 数据 + 模板生成新的生成新的虚拟 DOM ；
                    <div id="abc"> <span> hello world </span></div>;
                        [ 标签名（‘div’）,标签属性-- {id: 'abc'} , 内容-- [ 标签名-- 'span', 标签属性--- {}，标签内容--- ‘bye bye’]],
                7 比较原始虚拟 DOM 和新的虚拟 DOM 的区别，找出span 中的内容；
                8 直接操作 DOM； 改变 span 中的内容；


                总结： 虚拟 DOM 性能好的原因就是 在生成的虚拟 DOM 就是一个就是的对象； js 对象的比对，性能消耗很小；真实 DOM 的比对性能消耗很高； 
                


